# 命名
- [ ] 意図が伝わる命名をしている
- [ ] プログラミング用語やコンピュータ用語に基づいた名前を使用していない
- [ ] 変数の使い回しをしていない
- [ ] ビジネス目的を名前として表現している
- [ ] 存在ベースではなく目的ベースの命名にしている
- [ ] 省略された命名をしていない

# 変数設計
- [ ] 再代入する必要がない変数はイミュータブルにする
- [ ] インスタンスを使いまわしていない

# 関数設計
- [ ] 意味のあるまとまりで関数にしている
- [ ] プリミティブな型の引数は必要最小限である
- [ ] 静的メンバ関数は必要最小限である
    - [ ] 横断的な関心は静的メンバ関数にしても良い
- [ ] 初期化ロジックが多い場合、ファクトリメソッドを使用している
- [ ] 出力引数は凝縮性に問題がない場合のみ使用している
- [ ] 引数が多すぎない
- [ ] ロジックは呼ぶ側ではなく呼ばれる側に実装している

# クラス設計
- [ ] データとロジックが密であるものは同じオブジェクトに存在する
- [ ] クラス単体で動作する
- [ ] コンストラクタを呼び出すことで正常に動作するオブジェクトが生成される
- [ ] 生成ロジックが複雑である場合、ファクトリクラスを使用している
- [ ] 1つのクラスはそのクラスのみ責任をおっている
- [ ] 継承を必要以上に使用していない
- [ ] 関係しないもの同士が同じクラスに存在していない
- [ ] 1つのクラスは100行から200行程度
- [ ] Getter、Setterを使用していない

# 条件分岐設計
- [ ] ネストは2段以下である
- [ ] 早期リターンができる場合リターンをしている
- [ ] 同じ条件のswitch文が複数存在しない
- [ ] switch文が大きくなりすぎるならストラテジパターンを使用している

# コメント
- [ ] ロジックをなぞるだけのコメントをしていない

# その他
- [ ] 将来必要になりそうな機能を実装していない
- [ ] 深すぎるメソッドチェインを使用していない
- [ ] コレクション処理はカプセル化してある
- [ ] 同じようなロジック、似たようなロジックを共通化していない
- [ ] マジックナンバーを使用していない
- [ ] 例外を握りつぶしていない
